---
layout:     post
title:  Linux 内核之旅（十四）：Linux内核的页表体系
subtitle:   
date:       2025-04-25
author:     pandaychen
header-img:
catalog: true
tags:
    - Linux
    - Kernel
---

##  0x00    前言
前文

-   []()

虚拟内存是 CPU 和内核使用的一个障眼法，让进程误以为自己独占了全部的内存空间（对进程而言，它们各自看到的虚拟内存空间地址范围都是一样的）。如此内核为每个进程营造出一片独立的虚拟地址空间，使得进程与进程之间相互隔离，解决了多进程同时运行时产生的内存地址冲突问题。比如在 `32` 位系统中，进程以为自己独占了 `3G` 的内存空间，而在 `64` 位系统中，进程以为自己独占了 `128T` 的内存空间

当程序运行起来就变成了进程，在进程的视角里这些业务数据结构的引用（访问）全都都是虚拟内存地址，**因为进程无论是在用户态还是在内核态能够看到的都是虚拟内存空间，物理内存空间被操作系统所屏蔽进程是看不到的**，但当程序运行起来之后，程序中所需要的数据本质上还是保存在物理内存中的，即最终虚拟内存空间中每一个虚拟内存地址都是要映射到物理内存空间的中某一个特定物理内存地址上。进程虚拟内存空间中的每一个字节都有与其对应的虚拟内存地址，同样物理内存空间中每一个字节都有与其对应的物理内存地址（不然为什么叫虚拟内存）

-   在内存模型中，哪些是虚拟内存（概念），哪些是物理内存（概念）

##  0x01    基础知识

####    物理内存页 VS 虚拟内存页
1、物理内存页：内核管理物理内存的最小单位（通常为 `4KB`）

内核会将整个物理内存空间划分为一页页大小相同的的内存块（每个内存块大小为 `4K`），即物理内存页。一页大小的内存块在内核中用 `struct page` 来进行管理，`struct page` 中封装了每页内存块的状态信息，[参考]()。内核会为每个物理内存页 page 进行统一编号（Page Frame Number，即PFN），PFN 与 struct page 是一一对应的关系并且全局唯一

2、虚拟内存页：多级页表项（无单一结构体）

虚拟内存页没有独立的结构体，其映射关系通过页表层级结构描述，由硬件架构相关的页表项（Page Table Entry, 即PTE）管理

虚拟内存与物理内存的映射以及调度均是以页为单位进行的

####    虚拟内存页的类型

![page_type](https://raw.githubusercontent.com/pandaychen/pandaychen.github.io/refs/heads/master/blog_img/kernel/memory/pagetable/vm_page_type-1.png)

如上图：
1.  未分配页面（灰）：进程的虚拟内存空间size远超物理内存空间，进程对虚拟内存的使用也是需要向内核申请的（如`mmap`）。进程虚拟内存空间中的虚拟内存页在未被进程申请之前的状态就是未分配页面
2.  已分配未映射页面（紫）：在进程中可以通过glibc的 `malloc` 或者直接通过系统调用 `mmap` 向内核申请虚拟内存，申请到的虚拟内存页此时就变为了已分配的页面。但此时的虚拟内存页只是虚拟内存，还未与物理内存建立映射
3.  正常页面（绿）：当进程开始读写这些已分配未映射的虚拟内存页时，在 CPU 中用于地址翻译的硬件 MMU 会产生一个缺页中断，随后内核会为其分配相应的物理内存页面，并将虚拟内存页与物理内存页映射起来。此时进程就可以正常读写这些虚拟内存页

####    虚拟内存-->物理内存：映射关系的管理
虚拟内存跟物理内存要如何对应？让虚拟地址能够索引到物理内存单元，但是虚拟地址和物理地址显然不能一一对应，因此需要在虚拟地址空间与物理地址空间之间加一个类似的转换函数`p=f(v)`，该函数传入一个虚拟内存地址，它就能返回一个物理地址。此外，对于没法计算的地址或者没有权限的地址，还能返回一个禁止访问。这个函数对应的硬件就是 CPU 中的 MMU（内存管理单元），可以简单理解，为了高效对虚拟地址和物理地址转换，MMU 使用一个地址转换表

这个地址转换表就是页表，页表本质也是一个物理内存页（当然要存储在内存中），只不过这个物理内存页比较特殊，里面存放的是 PTE（Page Table Entry），用于保存虚拟内存与物理内存的映射关系。既然它是一个普通的物理内存页，那么也会参与内核的调度，既会被内核 swap in 以及 swap out，也会被缓存在 CPU 高速缓存中加速访问

####    PTE（Page Table Entry）
内核会在页表中划分出来一个个大小相等的小内存块，即页表项 PTE（Page Table Entry），**PTE 保存了进程虚拟内存空间中的虚拟页与物理内存页的映射关系，以及控制物理内存访问的相关权限位**，通常在 `32` 位系统中页表中的 PTE 占用 `4byte` ，`64` 位系统中页表的 PTE 占用 `8byte`，因为内存映射的粒度是按照页为单位进行的，所以进程虚拟内存空间中的每个虚拟页在页表中都会有一个 PTE 与之对应，而虚拟页背后映射的物理内存页的起始地址就保存在 PTE 中

![pte](https://raw.githubusercontent.com/pandaychen/pandaychen.github.io/refs/heads/master/blog_img/kernel/memory/pagetable/pte.png)

####    虚拟内存地址
虚拟内存地址（比如`64`位内核，内核空间虚拟地址`ffffffff8101bd40`、用户空间虚拟地址`0x7fffa9b07c14`）的意义是什么？进程虚拟内存空间中的每一个字节都有一个虚拟内存地址来表示，格式为**页表内偏移 + 物理内存页内偏移**，进程虚拟内存空间中的每一个虚拟页在页表中都会有一个 PTE 与之对应，专门用来存储该虚拟页背后映射的物理内存页的起始地址

![virtual-address-1]()

![virtual-address]()


虚拟内存地址格式中的页表内偏移就是专门用来定位虚拟内存页在页表中的 PTE 的，因为页表本质其实还是一个物理内存页，而一个物理内存页里边的内存肯定都是连续的，每个 PTE 的尺寸又是相同的，所以可以把页表看做一个数组，PTE 看做数组里的元素，在数组中定位元素直接通过数组索引 index 即可，这个索引 index 就称为页表内偏移

这样一来，CPU要访问某个虚拟内存地址，内核会先从这个虚拟内存地址中提取出页表内偏移，然后根据**页表起始地址 + 页表内偏移 * sizeof(PTE)** 就能获取到该虚拟内存地址所在虚拟页在页表中对应的 PTE 了

TODO：虚拟内存地址的可表示上限

####    页表起始地址（寻址过程）

TODO

####    PTE && 虚拟内存地址 && （单级）页表
单级页表的场景中，

![level-1-access-virtualaddress]()

####    PDE

####    页表的分类
而 CPU 无论是在用户态还是在内核态，访问的均是虚拟内存地址，不管是用户空间的虚拟内存地址还是内核空间的虚拟内存地址最终都是要与物理内存进行映射的，而通过前边的介绍我们也知道了，虚拟内存与物理内存的映射关系是通过页表来管理的

-   进程用户态页表：主要负责管理进程用户态虚拟内存空间到物理内存的映射关系
-   内核态页表：主要负责管理内核态虚拟内存空间到物理内存的映射关系，主要供内核使用

```CPP
//内核态虚拟内存空间的定义：struct mm_struct 结构
struct mm_struct init_mm = {
  .mm_rb    = RB_ROOT,
  .pgd    = swapper_pg_dir,
  .mm_users  = ATOMIC_INIT(2),
  .mm_count  = ATOMIC_INIT(1),
  .mmap_sem  = __RWSEM_INITIALIZER(init_mm.mmap_sem),
  .page_table_lock =  __SPIN_LOCK_UNLOCKED(init_mm.page_table_lock),
  .mmlist    = LIST_HEAD_INIT(init_mm.mmlist),
  .user_ns  = &init_user_ns,
  INIT_MM_CONTEXT(init_mm)
};
```

##  0x01    寻址过程（基础）
以单级页表为例，CPU访问虚拟内存地址的过程

![]()

##  0x02    内核态的页表
内核线程（始终工作在内核空间中）与普通进程不同，内核线程只能运行在内核态，而在内核态中，所有进程看到的虚拟内存空间全部都是一样的，所以对于内核线程来说并不需要为其单独的定义 `mm_struct` 结构来描述内核虚拟内存空间，内核线程的 `struct task_struct` 结构中的 `mm` 为 `NULL`，内核线程之间调度是不涉及地址空间切换的，从而避免了无用的 TLB 缓存以及 CPU 高速缓存的刷新

##  0x03    （单）多级页表
前面已经介绍了页表的若干基础概念，本小节介绍下单级、多级页表的设计，其中典型如`32`位机器的二级页表，`64`位机器的四级页表

-   页表的本质其实就是一个物理内存页（即一张页表 `4K` 大小），如在 `32bit` 系统中，页表中的一个 PTE 占用 `4B` 大小，所以一张页表可以容纳 `1024` 个 PTE，即一张页表可以映射 `1024 * 4K = 4M` 大小的物理内存

####    单级页表的局限性
根据上文了解到，在进程中虚拟内存与物理内存的映射是以页为单位的，进程虚拟内存空间中的一个虚拟内存页映射物理内存空间的一个物理内存页，这种映射关系以及访存权限都保存在 PTE 中，所以进程中的一个虚拟内存页对应页表中的一个 PTE，一个 PTE 能够映射 `4K` 的物理内存，一张页表可以映射 `1024 * 4K = 4M` 的物理内存。即对单个进程而言，如果需要访问`4M`大小的内存，那么需要用额外的`4K`物理内存（一个页表占用）来映射这`4M`的物理内存（总占用量是`4M+4K`）

假设系统中有 `4G` 的物理内存，那么需要 `1024` 张页表来映射，一张页表占用 `4K` 物理内存，并且为了映射这 `4G` 物理内存，额外需要 `1024*4K=4M` 的物理内存（即`1024`张页表）来映射。此外，这 `4M` 物理内存（`1024`张页表）**必须是连续的**，由于是单级页表（页表相当于是 PTE 的数组），进程虚拟内存空间中的一个虚拟内存页对应一个 PTE，而 PTE 在页表这个数组中的索引 index 就保存在虚拟内存地址中，内核通过页表的起始地址加上这个索引 index 才能定位到虚拟内存页对应的 PTE，进而通过 PTE 定位到映射的物理内存页

进一步说，因为进程的虚拟内存空间都是独立的，页表也是独立的，一个进程就需要额外的 `4M` 连续物理内存来支持进程内独立的内存映射关系。那么 `100` 个进程就需要额外的 `400M` 连续的物理内存，这是极大的浪费（根据程序局部性原理，某一个特定的时刻，进程只需要很少的物理内存就可以正常运转，那么进程虚拟内存与物理内存之间的映射关系相应也会很少，根本就不需要 `4M` 的物理内存来保存映射关系）

![single-page](https://raw.githubusercontent.com/pandaychen/pandaychen.github.io/refs/heads/master/blog_img/kernel/memory/pagetable/single-page-table-bad-case1.png)

![single-page](https://raw.githubusercontent.com/pandaychen/pandaychen.github.io/refs/heads/master/blog_img/kernel/memory/pagetable/single-page-table-bad-case2.png)

所以，可以采取分级的机制来避免因连续性要求的单级页表本身造成的资源浪费

##  0x  32位：二级页表
二级页表中的一个 PTE 本质上指向的还是一个物理内存页，即二级页表中也包含了 `1024` 个 PTE，其中每个PTE指向一个物理内存页（一级页表），如此一张二级页表就可以映射 `4G` 的物理内存。一般称二级页表中的 PTE为页目录项 (Page Directory Entry即PDE)，即一级页表的索引

对比单级页表，二级页表的内存占用：
1.  内核只需要一张 `4K` 的页目录表和一张 `4K` 的一级页表总共 `8K` 的内存就可以支持进程访问一个 `4K` 物理页面
2.  进程访问 `4M` 的物理内存，依然只需要一张 `4K` 的页目录表和一张 `4K` 的一级页表即可
3.  进程访问 `8M` 的物理内存，需要一张`4K`页目录表和两张一级页表共 `12K` 额外的物理内存
4.  极端情况，整个二级页目录表都被映射满了，这时候内核就需要 `4K`（页目录表）+ `4M`（`1024`张一级页表）的额外内存来保存映射关系
5.  在二级页表体系下，上面极端情况中的这 `1024` 张一级页表不要求连续的，只需要保证顶级页表（即PDE页目录表）是连续即可，通过页目录表中的 PDE 可以唯一索引到一张一级页表的起始物理内存地址，而页表内肯定是连续的 `4K` 物理内存，所以依然可以通过数组的方式索引到一级页表中的 PTE，进而找到其映射的物理内存页面

![level-2-page-table](https://raw.githubusercontent.com/pandaychen/pandaychen.github.io/refs/heads/master/blog_img/kernel/memory/pagetable/level-2-page-table.png)

####   32 位页表项 PTE 
在进程的虚拟内存空间中，每一个虚拟内存页在页表中都有一个 PTE 与之对应，在 `32` 位系统中，每个 PTE 占用 `4byte`，其保存了虚拟内存页背后映射的物理内存页的起始地址，以及进程访问物理内存的一些权限标识位，布局如下：

![32bit-pte]()

```CPP
//unsigned long 在32位系统中占用4字节
typedef unsigned long	pteval_t;
typedef struct { pteval_t pte; } pte_t;
```

####    32 位页目录项 PDE

## 0x    64位：四级页表

####    64位虚拟内存地址

![64bit-virtual-address]()

####    64 位页表项 PTE

####    64 位页目录项


####    四级页表寻址

![64-transform]()

####    
![64bit-page-table]()

##  0x  CPU 的寻址过程
为了加速虚拟内存地址到物理内存地址的转换过程，CPU 专门引入对页表进行遍历的地址翻译硬件 MMU（Memory Management Unit）加速这过程

![MMU]()

##  0x  参考
-   [Linux内存管理](https://qiankunli.github.io/2019/05/31/linux_memory.html#%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%A1%B5%E8%A1%A8)
-   [一步一图带你构建 Linux 页表体系 —— 详解虚拟内存如何与物理内存进行映射](https://www.cnblogs.com/binlovetech/p/17571929.html)