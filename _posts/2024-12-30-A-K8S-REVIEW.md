---
layout: post
title: Kubernetes 拾遗（持续补充）
subtitle:  
date: 2024-12-30
author: pandaychen
catalog: true
tags:
  - Kubernetes
---

## 0x00 前言

##  0x01  基础知识

####  k8s基本架构

![k8s_arch](https://raw.githubusercontent.com/pandaychen/pandaychen.github.io/refs/heads/master/blog_img/kubernetes/k8s_arch_1.jpg)

- apiServer：资源操作的唯一入口，接收用户输入的命令，提供认证、授权、API注册和发现等机制，通过标准的RESTFul API，重新封装了对 ETCD 接口调用，提供系统内其他组件调用的代理入口
- scheduler：负责集群资源调度，按照预定的调度策略将Pod调度到相应的node节点上
- controllerManager：负责维护集群的状态，比如程序部署安排、故障检测、自动扩展、滚动更新等
- etcd：负责存储集群中各种资源对象的信息，k/v方式存储，所有的 k8s 集群数据存放在此。此外，各个组件通信都并不是互相调用 API 来完成的，而是把状态写入 ETCD（相当于写入一个消息），其他组件通过监听 ETCD 的状态的的变化（相当于订阅消息），然后做后续的处理，然后再一次把更新的数据写入 ETCD
- kuberctl：命令行配置工具
- node：集群的数据平面，负责为容器提供运行环境
- kubelet：负责维护容器的生命周期，即通过控制docker，来创建/更新/销毁容器，会按固定频率检查节点健康状态并上报给 APIServer，该状态会记录在 Node 对象的 status 中
- kubeProxy：负责提供集群内部的服务发现和负载均衡
- docker（runtime）：负责节点上容器的各种操作

####  Linux VS kubernetes

![linux-vs-k8s](https://raw.githubusercontent.com/pandaychen/pandaychen.github.io/refs/heads/master/blog_img/kubernetes/linux_vs_kubernetes.jpg)

####  声明式应用管理
Kubernetes 总体设计遵循控制器模式，用户通过 YAML 文件等方式来表达所需要的期望状态也就是终态（无论网络、存储等），然后 Kubernetes 的各种组件就会让整个集群的状态跟用户声明的终态逼近，最终达成两者的完全一致。这个实际状态逐渐向期望状态逼近的过程，就叫做 reconcile（调谐），同样 Operator 和自定义 Controller 也类似此工作方式

声明式应用管理的本质即Infrastructure as Data/Configuration as Data，基础设施的管理不应该耦合于某种编程语言或者配置方式，而应该是纯粹的、格式化的、系统可读的数据，并且这些数据能够完整的表征使用者所期望的系统状态。任何时候对基础设施做操作，最终都等价于对这些数据的增/删/改/查。若想在 Kubernetes 上做任何操作，只需要提交一个 YAML 文件，然后对这个 YAML 文件进行增删改查即可，而无需使用 Kubernetes 项目的 Restful API来完成。此YAML 文件里的内容本质就是 Kubernetes 系统对应的 Data（简单理解就是API对象等同于具有不同类型固定格式的Data）。**Kubernetes 本质上其实是一个以数据（Data）来表达系统的设定值、通过控制器（Controller）的动作来让系统维持在设定值的调谐系统**

通俗点说，kubernetes的本质是一个数据库，那么相关分类如下：

- 数据模型：Kubernetes 的各种 API 对象与 CRD 机制
- 数据拦截校验和修改机制：Kubernetes Admission Hook
- 数据驱动机制：Kubernetes Controller/Operator
- 数据监听变更与索引机制：Informer 机制

####  k8s的组件

| 组件 | 作用 | 归属 |
| :-----| :---- | :---- |
| kubectl |  |  |
| kubelet |  |  |
| cri-shim |  |  |
| csi |  |  |
| cni plugin |  |  |

####  k8s核心组件的实现思路
在k8s中，与apiserver 通信的Controller/Scheduler 的业务逻辑可以抽象为如下模型，如图所示：

- 若组件需要与apiserver 交互（通信），k8s抽象了通用Informer 框架（**实现在 apiserver 的 访问包client-go**）负责apiserver 数据的本地cache及监听。Informer 还会比对资源是否变更（依靠内部的Delta FIFO Queue），只有变更的资源才会触发handler
- 组件都采用control loop 逻辑
- 组件内部维护一个 queue队列，通过注册Informer事件函数保持queue数据的更新，作用相当于队列的生产者，而control loop 作为队列的消费者
- 通过 Informer 提供过的 Lister 拥有遍历数据的能力，将操作结果重新通过kubeclient 写入到apiserver

![component_overview](https://raw.githubusercontent.com/pandaychen/pandaychen.github.io/refs/heads/master/blog_img/kubernetes/component_overview.png)

####  编排系统的设计

1、资源模型的抽象

- 有哪些种类的资源，如CPU、内存等
- 如何用数据结构表示这些资源

2、资源的调度设计

- 如何描述一个 workload 的资源申请（spec），如该容器需要 `4` 核和 `12GB~16GB` 内存
- 如何描述一台 node 当前的资源分配状态，例如已分配/未分配资源量，是否支持超分等

3、调度算法设计：如何根据 workload spec 为它挑选最合适的 node

4、资源的限额（capacity enforcement）

- 如何确保 workload 使用的资源量不超出预设范围（从而不会影响其他 workload）
- 如何确保 workload 和系统/基础服务的限额，使二者互不影响


##  0x01  review：基础概念

####  pod

####  pod 控制器

####  service

2、NodePort

![node-port](https://raw.githubusercontent.com/pandaychen/pandaychen.github.io/refs/heads/master/blog_img/kubernetes/svc_nodeport.jpg)

3、Loadbalance

![Loadbalance](https://raw.githubusercontent.com/pandaychen/pandaychen.github.io/refs/heads/master/blog_img/kubernetes/svc_lb.jpg)

####  volume

##  0x03 参考
