---
layout:     post
title:  Linux 内核CVE：CVE-2022-0847
subtitle:   Linux 内核 DirtyPipe 任意只读文件覆写漏洞分析
date:       2025-08-03
author:     pandaychen
header-img:
catalog: true
tags:
    - Linux
    - Kernel
---

##  0x00    前言
前文[Linux 内核之旅（十五）：管道的实现](https://pandaychen.github.io/2025/07/01/A-LINUX-KERNEL-TRAVEL-15/)介绍了管道机制的内核实现原理，本文学习一个基于管道机制的非常有趣的CVE实现：[CVE-2022-0847](https://dirtypipe.cm4all.com/)

本文基于漏洞影响版本[v5.13](https://elixir.bootlin.com/linux/v5.13)来进行分析

##  0x01    CVE介绍
相关的poc代码[参考此](https://github.com/pandaychen/ebpf-allinone/blob/main/cve/2022-0847.c)，抽象为如下代码结构，这里面包含的五个步骤缺一不可

```CPP
// 1、创建管道
int p[2];
pipe(p);

// 2、填充管道（创建带有PIPE_BUF_FLAG_CAN_MERGE标志的缓冲区）
for (int i = 0; i < 8; i++)
    write(p[1], "A", 1);

// 3、清空管道（保留缓冲区结构）
for (int i = 0; i < 8; i++)
    read(p[0], &buf, 1);

// 4、使用splice将文件内容导入管道（关键漏洞触发点）
ssize_t nbytes = splice(file_fd, &file_offset, p[1], NULL, 1, 0);

// 5、向管道写入恶意数据（利用漏洞覆盖文件缓存）
write(p[1], evil_data, evil_data_len);
```

1、在受影响内核版本中，使用 `splice` 系统调用从一个只读文件（如`-r--r--r--`）向一个管道中传输数据时，会使管道用于保存数据的缓冲区共享文件的 page cache，从而实现零拷贝。但是，由于 `PIPE_BUF_FLAG_CAN_MERGE` 标志位的存在，调用 `splice` 之后再向管道中写入数据时，写入的数据会直接写到文件的 page cache 中（虽然文件是只读，但是可以通过这种巧妙的方式写入到文件page cache）

2、当另一个进程（可能是系统相关）在读此文件时，会触发读到page cache（Buffered IO），由于该文件的page cache已经被污染了，所以读到的是上一步中的写入后的脏页数据

3、低权限用户可利用此漏洞向本没有写权限的文件中写入数据，进而实现提权等恶意行为

####   POC代码的若干细节
先介绍下漏洞利用涉及的若干细节：

-   创建一个管道（不指定 `O_DIRECT`）
-   将管道填充满（通过 `write()-->pipe_write()`每次写入整页），这样所有的 pipe 缓存页都初始化过了，`pipe->flags` 被初始化为`PIPE_BUF_FLAG_CAN_MERGE`，关联[代码](https://github.com/pandaychen/ebpf-allinone/blob/main/cve/2022-0847.c#L57)
-   将管道清空（通过`read()-->pipe_read()`），这样通过 `splice` 系统调用传送文件的时候就会使用原有的初始化过的buf结构，关联[代码](https://github.com/pandaychen/ebpf-allinone/blob/main/cve/2022-0847.c#L65)
-   打开待覆写文件，调用 `splice()` 将往pipe写入`1`字节（这样才能将page cache索引到`pipe_buffer`），关联[代码](https://github.com/pandaychen/ebpf-allinone/blob/main/cve/2022-0847.c#L134C53-L134C54)
-   最后，调用 `write()` 继续向pipe写入小于`1`页的数据（`write()-->pipe_write()`），这时就会覆盖到文件缓存页了，暂时篡改了目标文件。只要没有其他可写权限的程序进行`write`操作，该页面并不会被内核标记为dirty（内核其实也并不知道），也就不会进行页面缓存写会磁盘的操作，此时其他进程读文件会命中页面缓存，从而读取到篡改后到文件数据， 但重启后文件会变回原来的状态

####    漏洞限制
-   被"覆写"的目标文件必须拥有可读权限，否则`splice()`无法进行
-   由于是在`pipe_buffer`中覆写页面缓存的数据，又需要`splice()`读取至少`1`字节的数据进入管道，所以覆盖时，每个页面的第一个字节是不可修改的，同样的原因，单次写入的数据量也不能大于`4kB`，思考下，这个操作的意义是什么？
-   由于需要写入的页面都是内核通过文件IO读取的page cache, 所以任意写入文件只能是单纯的覆写，不能调整文件的大小
-   漏洞被命名为 DirtyPipe，和 CVE-2016-5195 DirtyCOW 一样，两个漏洞的触发点都在于Linux内核对于文件读写操作的优化（写时拷贝/零拷贝）。DirtyPipe的利用方法更简单，因为不需要竞争，顺序操作就能直接触发漏洞

##  0x0 参考
-   [Linux 内核 DirtyPipe 任意只读文件覆写漏洞（CVE-2022-0847）分析](https://www.anquanke.com/post/id/269886)
-   [CVE-2022-0847 Dirty Pipe linux内核提权分析](https://github.com/chenaotian/CVE-2022-0847)