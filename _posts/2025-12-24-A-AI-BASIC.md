---
layout:     post
title:      AI 关键点摘要
subtitle:   
date:       2025-12-24
author:     pandaychen
catalog:    true
tags:
    - AI
---


##  0x00    前言

##  0x01    AI 基础（白话）

1、LLM (大语言模型) ：超级大脑

所有 AI 的底座，可以把它想象成一个读过人类历史上所有书籍、见过所有代码、博古通今的超级学霸。它能理解你的意图，也能跟你聊天，但它本质上只是一个大脑，暂时还没手没脚

2、Agent （智能体） ：全能数字员工

如果 LLM 只是个大脑，那么 Agent 就是一个有了身体、目标、会思考的员工。

区别：问 LLM 问题，它回复你答案；给 Agent 一个任务（比如：帮我策划一场旅行并订好机票），它会自己拆解步骤、查资料、做决策，直到把事办完

3、RAG （检索增强生成） ：开卷考试

LLM 虽然博学，但它的知识有截止日期（比如不知道昨天的新闻）。RAG 就像是给这位学霸发了一本实时更新的参考书。当用户提问问题时，系统先去自己的私人数据库里翻一翻相关的资料（检索），再把资料喂给 LLM（增强），让它看着资料回答（生成）

4、Skills & Tools：手里的家伙事儿

-   Tools （工具） ： 这是 AI 能调用的外部功能。比如计算器、天气预报接口、Google 搜索等等，这让 AI 从只会动嘴变成了能干实事
-   Skills（技能）： 通常指 Agent 被赋予的一套组合动作。比如写周报是一个技能，它包含了读取日志、润色文字、发送邮件这一整套逻辑

5、MCP （模型上下文协议） ：统一的电源插头

MCP 就像是 USB-C 接口。只要大家都遵守这个标准，AI 就能无缝地插进各种数据库和软件里，直接读取数据，不用到处适配

6、Rules （规则/指令） ：员工手册

这是你给 AI 下的硬性规定。比如：回答必须简洁、不准说脏话、代码必须用 Python 写等等。它是用来约束 AI 行为的边界，防止它放飞自我

7、Vibe-coding & Spec-coding ：编程新姿势

-   Vibe-coding （氛围感编程）： 核心在于感觉。开发者不再写一行行的具体代码，而是通过和 AI 聊天，描述想要的效果（Vibe），让 AI 像魔法一样把功能变出来。主打一个顺手、直觉、高效
-   Spec-coding （规格驱动编程）： 核心在于严谨。你先写一份非常详细的说明书（Spec），规定好每一个功能细节。AI 就像一个完美的搬砖工，严格按照你的蓝图去施工，出错率极低

##  0x0 大模型（LLM）
LLM 是一个**读过海量资料、会接话、会写代码的超级助理大脑**，通俗解释可以把大模型想成一个：

-   读完了互联网上大量文字、代码、文档
-   学会了**下一句话应该怎么接**的超强概率机器

它本身不懂对错、不理解业务，只是在做一件事，即**在当前上下文下，最有可能出现的下一个词是什么**。由于它读过的东西实在太多，所以它的技能主要还是：

-   会写代码
-   会设计方案
-   会解释概念

不过，LLM不等于工具， 也不会自动干活（只能被动），它只是一个大脑，要干活还得配手（工具）和规则

##  0x0 Tools
Tools 是让 AI 干一件具体小事的具体工具，其特点是

-   单一功能
-   输入 -> 输出
-   不关心前后流程（给输入执行，并输出）

常用的实现有：

-   读取文件
-   写文件
-   执行命令
-   调用接口
-   查询数据库

##  0x0 Skills
Skills 就是让大模型真的能干活的具体能力按钮（工具），通俗解释，如果把 LLM 看作一个聪明人：

-   LLM：脑子很聪明
-   Skills：给LLM配的工具和技能

比如在 Cursor/Claude CLI 里使用到的功能：能直接改项目/知道上下文/能跑测试等等，本质都是 Skills 在起作用。对于没有 Skills 的 LLM，只能聊天/只能建议/不能落地

| Skill | 大白话 |
| :-----| :---- | 
| 写文件 | 能真的在你项目里创建 / 修改代码 |
| 运行命令 | 能帮你 `npm test` / `docker build`等 | 
| 查数据库 | 能查数据、生成 SQL|
| 读（分析）项目| 能理解整个项目上下文 |

####    Tools 和 Skills 的区别
1、Tool，一般是点一下干一件事，如查日志、查代码、查配置

2、Skill，知道先干啥、再干啥、最后干啥。如**查日志 --> 查代码 --> 查配置 --> 给结论**

3、一个 Skill，通常等于多个 Tool 按顺序组合起来

##  0x0 MCP（Model Context Protocol）
MCP 是给大模型统一接外部能力的插线板标准，只要你按 MCP 协议提供能力，任何支持 MCP 的大模型 / Agent 都能用你（MCP）。比如开发者实现了如下能力列表（基于MCP规范），可以实现为一个Server或者封装为tools的集合，这样claude cli/cursor都可以使用

1.  查公司内部接口文档
2.  调用内部服务
3.  访问私有仓库

常用[]()

##  0x0 Rules
Rules 是约束大模型别乱来、别自作聪明的行为规范，由于 LLM 天性（太积极/太自信/太爱发挥），所以需要立规矩（Rules），通常要指定：

-   你是谁
-   你能干什么
-   你不能干什么
-   遇到不确定时怎么办

如在 Cursor 里优化代码，需要明确指定：能改哪些文件/不能做哪些事/是否允许引入新依赖/不确定时如何处理/只修改我点名的文件/指定代码风格/指定文档风格等等

Rules 本质上是**把隐性经验变成显性约束**，把人的经验，变成 AI 必须遵守的约束

##  0x0 Vibe-coding（感觉编程）
Vibe-coding即用户大概说个意思，你自由发挥写代码，典型对话如下。如**给我写一个网页，要看起来像80年代的科幻电影，霓虹灯风格，有个会动的飞船在背景里**

```
帮我写个登录功能
大概差不多就行
你看着办
```

结果可能是（快、错误多）

```
AI 写一大堆
能跑，但不一定对
架构未必符合你项目
```

比较适合Demo/原型验证/学习新技术/一次性脚本等简单快速场景，不适合复杂业务/长期维护/团队协作等

##  0x0 Spec-coding（规格编程）
Spec-coding，即我（用户）先写清楚规格，你（AI）严格按说明实现。一种场景是先给 AI 一个明确说明书（Spec）：

```
目标和背景
输入 / 输出
修改范围
约束条件
边界情况
代码规范
```

要求精确控制每一个细节, 然后 AI 才开始写代码。此时用户是产品 + 架构师，而AI 是一个执行力极强的高级工程师（稳定/可复用/规范/可协作等），较为适合真实业务 + 团队开发

####  Spec-coding VS Rules

-   rules：长期规则（全局）
-   spec coding：一次任务的临时规格

##  0x0 Agent（重要）
Agent（智能体）：会自己做决定、会调用工具、会把事情一步步做完的 AI 执行者，大模型的全权委托代理人。Agent 的四大核心组件：

1.  大脑 （LLM）： 负责思考、理解你的意图、拆解任务
2.  规划 （Planning）： 它是走一步看三步的。它会想为了完成目标，我第一步干啥，第二步干啥，如果出错了怎么办？
3.  记忆 （Memory）：包括短期记忆（记得刚才聊了啥）、长期记忆（记得你的偏好，比如你只坐南航的飞机，或者你写代码喜欢用 Python等）
4.  工具箱 （MCP/Tools/Skills）： 能自主决定什么时候去翻帮内部文档（MCP）、什么时候去写代码(Tools)、什么时候去查天气 （Skills）

更形象的例子：

```
你（老板）站在工厂门口，面对着 Agent（你的员工）
Agent 里面装着一个 LLM（聪明的大脑）
Agent 身上插着 MCP（万能插座），随时能通过 Skills（工具）去干活
墙上贴着 Rules（家规），Agent 干活时不敢违反
如果你今天心情好，你就跟它玩 Vibe-coding（给我整点酷的）
如果你今天要上线大项目，你就给它发一份 Spec-coding（按图纸施工，别废话）
```

##  0x0 RAG

##  0x0 Relations


| :-----| :---- | 
| LLM | 会接话、会写代码的超级大脑 |
| Skills | 让 AI 真正能干活的工具能力 | 
| Tools | 干活使用的一个最小工具|
| MCP| 给 AI 接外部能力的统一协议 |
| Rules |约束 AI 行为的长期规矩|
|   Vibe-coding    |靠感觉让 AI 自由发挥|
|   Spec-coding    |用规格驱动 AI 精确执行|
|   Agent    |LLM + 规划 + 记忆 + Rules+MCP+Skills|

##  参考
-   [一篇搞懂AI通识:大白话拆解核心点](https://www.cnblogs.com/Jcloud/p/19492752)